"""
解码方法

一条包含字母 A-Z 的消息通过以下映射进行了编码：
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为 (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的非空字符串 s ，请计算并返回解码方法的总数 。

题目数据保证答案肯定是一个 32 位的整数。

示例 1：
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2：
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

示例 3：
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。

提示：
* 1 <= s.length <= 100
* s 只包含数字，并且可能包含前导零。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/decode-ways
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

标签：字符串、动态规划
"""


class Solution:
    def numDecodings(self, s: str) -> int:
        # 动态规划
        # 可分为2种编码方式，若s的最后一位∈[1,9]，则获得s[-1]的编码数，若s最后两位∈[10,26]，则获得s[-2]的编码数，两者相加即可
        length = len(s)
        way1, way2 = 1, int(s[0] != '0')  # 在后续遍历中s[:i]/s[:i+1]的编码数
        for i in range(1, length):
            way3 = 0
            if s[i] != '0':
                way3 += way2
            if s[i - 1] != '0' and int(s[i - 1: i + 1]) <= 26:
                way3 += way1
            way1, way2 = way2, way3
        return way2


if __name__ == '__main__':
    s = Solution()

    r = s.numDecodings('12')
    print(r)

    r = s.numDecodings('226')
    print(r)

    r = s.numDecodings('0')
    print(r)
